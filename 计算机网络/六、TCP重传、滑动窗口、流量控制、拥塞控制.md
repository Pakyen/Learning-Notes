# 六、TCP重传、滑动窗口、流量控制、拥塞控制

为了实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如 不能解决这些问题，也就无从谈起可靠传输。

TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。

![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page149image41901792%202.png) 

## 1. 重传机制
TCP 实现可靠传输的方式之一，是通过序列号与确认应答 

在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息 
				![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page150image41009152%202.png) 
但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢?

所以 TCP 针对数据包丢失的情况，会用**重传机制**解决 

常见的重传机制有：
	* 超时重传 
	* 快速重传 
	* SACK 
	* D-SACK 

### 1.1 超时重传
重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的**超时重传**

TCP 会在以下两种情况发生超时重传: 
	* `数据包` 丢失 
	* `ack` 确认应答丢失 

![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page151image41488032%202.png)
 
#### 1.1.1 超时时间应该设置为多少呢？
我们先来了解一下什么是 `RTT` (Round-Trip Time 往返时延)，从下图我们就可以知道: 
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-14%2012.17.51%202.png)
`RTT` 就是**数据从网络一端传送到另一端再回来所需的时间**，也就是`包的往返时间` 
超时重传时间是以 `RTO` (Retransmission Timeout 超时重传时间)表示。 假设在重传的情况下，超时时间 `RTO` 「较长或较短」时，会发生什么事情呢 

![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page152image41000880%202.png)
 
上图中有两种超时时间不同的情况:
	* 当超时时间 **RTO较大**时，重发就慢，丢了老半天才重发，没有效率，性能差;
	* 当超时时间 **RTO较小**时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发

精确的测量超时时间 RTO 的值是非常重要的，这可让我们的重传机制更高效 

根据上述的两种情况，我们可以得知，**超时重传时间RTO的值应该略大于报文往返RTT的值**
	![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page153image41012688%202.png) 
好像就是在发送端发包时记下 `t0` ，然后接收端再把这个 `ack` 回来时再记一个 `t1` ，于是 `RTT= t1– t0` 。没那么简单，**这只是一个采样，不能代表普遍情况**
实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个**动态变化的值**

![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-14%2012.29.43%202.png)
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page154image40946112%202.png) ![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-14%2012.30.27%202.png)

### 1.2 快速重传
TCP 还有另外一种**快速重传(Fast Retransmit)机制**，它**不以时间为驱动，而是以数据驱动重传**
	![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page155image41021424%202.png)
在上图，发送方发出了 1，2，3，4，5 份数据: 
	* 第一份 Seq1 先送到了，于是就 Ack 回 2; 
	* 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2 
	* 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到 
	* **发送端收到了三个Ack = 2的确认，知道了Seq2还没有收到，就会在定时器过期之前，重传丢失的Seq2**
	* 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 

所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段
快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是**重传的时候，是重传之前的一个，还是重传所有的问题**

比如对于上面的例子，是重传 Seq2 呢? 还是重传 Seq2、Seq3、Seq4、Seq5 呢?因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的 （有可能后面的也丢失了）

根据 TCP 不同的实现，以上两种情况都是有可能的。可见，这是一把双刃剑 
为了解决不知道该重传哪些 TCP 报文，于是就有 `SACK` 方法 


### 1.3 SACK方法：选择性确认 重传机制

还有一种实现重传机制的方式叫: ( Selective Acknowledgment 选择性确认）

这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它**可以将缓存的地图发送给发送方**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**

如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 `SACK` 信息发 现只有 `200~299` 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page156image41673456%202.png)
如果要支持 SACK ，必须双方都要支持。在 Linux 下，可以通过 `net.ipv4.tcp_sack`参数打开这个功 能(Linux 2.4 后默认打开) 


### D-SACK （Duplicate SACK）

Duplicate SACK 又称 `D-SACK` ，其主要**使用了SACK来告诉「发送方」有哪些数据被重复接收了**

下面举例两个栗子，来说明 `D-SACK` 的作用 

#### 例子1：ACK丢包
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page157image41915472%202.png)

	* 「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据 包(3000 ~ 3499) 
	* **于是「接收方」发现数据是重复收到的，于是回了一个SACK = 3000~3500**，告诉「发送方」 30003500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据 都已收到，所以这个 SACK 就代表着 `D-SACK `。 
	* 这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了 

 
#### 例子2：网络延时
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page158image41671168%202.png) 
	* 数据包(1000~1499) 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文
	* 而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的 数据包(1000~1499)又到了「接收方」
	* **所以「接收方」回了一个SACK=1000~1500，因为ACK已经到了3000，所以这个SACK是D-SACK，表示收到了重复的包**
	* 这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了

可见， `D-SACK` 有这么几个好处 ：
	1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了; 
	2. 可以知道是不是「发送方」的数据包被网络延迟了;
	3. 可以知道网络中是不是把「发送方」的数据包给复制了; 

在 Linux 下可以通过 `net.ipv4.tcp_dsack` 参数开启/关闭这个功能(Linux 2.4 后默认打开) 

- - - -
## 2 滑动窗口

### 2.1 引入窗口概念的原因 

我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个

这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的
如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实

			![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page159image41713088%202.png) 
所以，这样的传输方式有一个缺点：数据包的**往返时间越长，通信的效率就越低**。 
为解决这个问题，TCP 引入了**窗口**这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率

那么有了窗口，就可以指定窗口大小，窗口大小就是指::**无需等待确认应答，而可以继续发送数据的最大值**::

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除

假设窗口大小为 `3` 个 TCP 段，那么发送方就可以「连续发送」 `3` 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图: 
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page160image41670128%202.png) 
图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫**累计确认**或者**累计应答**

### 2.2 窗口大小由哪一方决定？（通常由接收方的窗口大小决定）
TCP 头里有一个字段叫 `Window` ，也就是窗口大小 

**这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来**

所以，::**通常窗口的大小是由接收方的窗口大小来决定的**::

发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据

### 2.3 发送方的滑动窗口
我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page161image41684640%202.png) 
	* #1 是已发送并收到 ACK确认的数据:1~31 字节
	* #2 是已发送但未收到 ACK确认的数据:32~45 字节（发送窗口：占20字节）
	* #3 是未发送但总大小在接收方处理范围内(接收方还有空间):46~51字节 （可用窗口：占6字节）
	* #4 是未发送但总大小超过接收方处理范围(接收方没有空间):52字节以后 

在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽， 在没收到 ACK 确认之前是无法继续发送数据了 
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page161image41685472%202.png) 
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-14%2013.48.46%202.png)


### 2.3.1 程序是如何表示发送方的四个部分的呢？

TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节
其中两个指针是绝对指针(指特定的序列号)，一个是相对指针(需要做偏移) 
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page162image40964992%202.png) 
	* `SND.WND` ：表示发送窗口的大小(大小是由接收方指定的);
	* `SND.UNA` ：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。
	* `SND.NXT` ：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。
	* 指向 #4 的第一个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND 
就可以指向 #4 的第一个字节了  = `SND.UNA + SND.WND`

	* 可用窗口的大小 = `SND.WND - (SND.NXT - SND.UNA)`


### 2.4 接收方的滑动窗口
接下来我们看看接收方的窗口，接收窗口相对简单一些，根据处理的情况划分成三个部分:
	* #1 + #2 是已成功接收并确认的数据(等待应用进程读取);
	* #3 是未收到数据但可以接收的数据;
	* #4 未收到数据并不可以接收的数据; 

其中三个接收部分，使用两个指针进行划分: 
	* `RCV.WND`：表示接收窗口的大小，它会通告给发送方
	* `RCV.NXT`：是一个指针，它指向期望从发送方发来的下一个数据字节的序列号，也就是#3的第一个字节
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page162image40963952%202.png) 
	* 指向 #4 的第一个字节是个相对指针，它需要 `RCV.NXT` 指针加上 `RCV.WND` 大小的偏移量， 就可以指向 #4 的第一个字节了 


### 2.5   接收窗口和发送窗口的大小是相等的吗?

并不是完全相等，接收窗口的大小是**约等于**发送窗口的大小的。 
因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接 收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发 送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系


## 3. 流量控制
发送方不能无脑的发数据给接收方，要考虑接收方处理能力
如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-15%2010.30.19%202.png)
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-15%2010.32.46%202.png)
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-15%2010.33.06%202.png)
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-15%2010.38.06%202.png)
 

### 3.1 操作系统缓冲区与滑动窗口的关系

前面的流量控制例子，我们假定了发送窗口和接收窗口是不变的，但是实际上，发送窗口和接收窗口中 所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会**被操作系统调整**

当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响



## 4. 拥塞控制

### 4.1 为什么要有拥塞控制？
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-15%2011.21.55%202.png)


### 4.2 什么是拥塞窗口？和发送窗口有什么关系呢？
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-15%2011.24.11%202.png)


### 4.3 怎么知道当前网络是否出现了拥塞？
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-15%2011.26.26%202.png)


### 4.4 拥塞控制有哪些控制算法？

	* 慢启动
	* 拥塞避免
	* 拥塞发生
	* 快速恢复


#### 4.4.1 慢启动算法

TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据 包的数量，如果一上来就发大量的数据，这不是给网络添堵吗? 

慢启动的算法记住一个规则就行:**当发送方每收到一个ACK，拥塞窗口cwnd的大小就会加1**
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-15%2011.36.32%202.png)
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-15%2011.36.44%202.png)
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-15%2011.42.32%202.png)


#### 4.4.2 拥塞避免算法
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E6%88%AA%E5%B1%8F2021-03-15%2011.57.17%202.png)
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page175image41906576%202.png) 
所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。
就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。
当触发了重传机制，也就进入了「拥塞发生算法」


#### 4.4.3 拥塞发生算法

当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种:
* 超时重传 
* 快速重传 
这两种使用的拥塞发送算法是不同的，接下来分别来说说

1. 发生超时重传时的拥塞发生算法

当发生了「超时重传」，则就会使用拥塞发生算法。 这个时候，ssthresh 和 cwnd 的值会发生变化: 
	* `ssthresh`设为`cwnd/2`
	* `cwnd`重置为1
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page176image41641728%202.png) 
接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。
就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。

2. 发生快速重传时的拥塞发生算法

还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前 一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。 

TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则`ssthresh`和`cwnd`变化如下：
	* `cwnd = cwnd/2`，也就是设置为原来的一半
	* `ssthresh = cwnd`
	* 进入快速恢复算法

#### 4.4.4 快速恢复算法

快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也 不那么糟糕，所以没有必要像 `RTO`（超时重传时间） 超时那么强烈 

正如前面所说，进入快速恢复之前， `ssthresh`和`cwnd`应被更新了：
	* `cwnd = cwnd/2`，也就是设置为原来的一半
	* `ssthresh = cwnd`

然后，进入快速恢复算法：

	* 拥塞窗口 `cwnd = ssthresh + 3` ( 3 的意思是确认有 3 个数据包被收到了); 
	* 重传丢失的数据包;
	* 如果再收到重复的 ACK，那么 cwnd 增加 1; 
	* 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的 状态了，也即再次进入拥塞避免状态; 
![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page177image41904288%202.png) 

也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。


![](%E5%85%AD%E3%80%81TCP%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/page178image40918960%202.jpg) 









