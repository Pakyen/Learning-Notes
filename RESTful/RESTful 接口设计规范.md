# RESTful 接口设计规范

## 1. 什么是REST
RESTful是目前最流行的API设计规范，它是用于Web数据接口的设计。从字面可以看出，他是Rest式的接口，所以我们先了解下什么是Rest。
REST与技术无关，它代表的是一种软件架构风格，REST它是 Representational State Transfer的简称，中文的含义是: “表征状态转移” 或 “表现层状态转化”。它是基于HTTP、URI、XML、JSON等标准和协议，支持轻量级、跨平台、跨语言的架构设计。

![](RESTful%20%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/EBFDC16C-EC17-4A7D-9051-D4D33517F0D5.png)

## 2. 理解Restful
要理解RESTful架构，需要理解Representational State Transfer这个词组到底是什么意思，它的每一个词都有些什么涵义。
下面我们结合REST原则，围绕资源展开讨论，从资源的定义、获取、表述、关联、状态变迁等角度，列举一些关键概念并加以解释。
	* 资源与URI
	* 统一资源接口
	* 资源的表述
	* 资源的链接
	* 状态的转移


### 2.1 资源与URI
REST全称是表述性状态转移，那究竟指的是什么的表述? 其实指的就是资源。任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值) 。下面是一些资源的例子：
	* 某用户的手机号码
	* 某用户的个人信息
	* 最多用户订购的GPRS套餐
	* 两个产品之间的依赖关系
	* 某用户可以办理的优惠套餐
	* 某手机号码的潜在价值

要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就 `URI(Uniform Resource Identifier)`。
**URI既可以看成是资源的地址，也可以看成是资源的名称**。如果某些信息没有使用URI来表示，那它就不能算是一个资源， 只能算是资源的一些信息而已。**URI的设计应该遵循可寻址性原则，具有自描述性**，需要在形式上给人以直觉上的关联。这里以github网站为例，给出一些还算不错的URI：
	* https://github.com/git
	* https://github.com/git/git
	* https://github.com/git/git/blob/master/block-sha1/sha1.h
	* https://github.com/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08
	* https://github.com/git/git/pulls
	* https://github.com/git/git/pulls?state=closed
	* https://github.com/git/git/compare/master…next


下面让我们来看看URI设计上的一些技巧:
	* 使用`_`或`-`来让URI可读性更好
	* 使用`/`来表示资源的层级关系
	* 使用`?`用来过滤资源
> 很多人只是把?简单的当做是参数的传递，很容易造成URI过于复杂、难以理解。可以把?用于对资源的过滤， 例如/git/git/pulls用来表示git项目的所有推入请求，而/pulls?state=closed用来表示git项目中已经关闭的推入请求， 这种URL通常对应的是一些特定条件的查询结果或算法运算结果。  
	* `,`或`;`可以用来表示同级资源的关系
> 有时候我们需要表示同级资源的关系时，可以使用,或;来进行分割。例如哪天github可以比较某个文件在随意两次提交记录之间的差异，或许可以使用/git/git /block-sha1/sha1.h/compare/e3af72cdafab5993d18fae056f87e1d675913d08;bd63e61bdf38e872d5215c07b264dcc16e4febca作为URI。 不过，现在github是使用…来做这个事情的，例如/git/git/compare/master…next。  

## 2.2 统一资源接口
Rest接口约束定义为: 资源识别；请求动作；响应信息; 它表示通过uri表示出要操作的资源，通过请求动作(http method)标识要执行的操作，通过返回的状态码来表示这次请求的执行结果。
> 可能看上面的解释还不够理解，下面我通过自己的理解来解释下上面的具体含义; 比如说，我在未使用Rest规范之前，我们可能有 增删改查 等接口，因此我们会设计出类似这样的接口: /xxx/newAdd (新增接口), /xxx/delete(删除接口), /xxx/query (查询接口), /xxx/uddate(修改接口)等这样的。**增删改查有四个不同的接口，维护起来可能也不好**，因此如果我们现在使用Restful规范来做的话，**对于开发设计来说可能就只需要一个接口就可以了，比如设计该接口为 /xxx/apis 这样的一个接口就可以了**，然后请求方式(method)有 GET—查询(从服务器获取资源); POST—新增(从服务器中新建一个资源); PUT—更新(在服务器中更新资源)，DELETE—删除(从服务器删除资源)，PATCH—部分更新(从服务器端更新部分资源) 等这些方式来做，**也就是说我们使用RESTful规范后，我们的接口就变成了一个了，要执行增删改查操作的话，我们只需要使用不同的请求动作(http method)方式来做就可以了，然后服务器端返回的数据也可以是相同的，只是我们前端会根据状态码来判断请求成功或失败的状态值来判断**。具体有那些状态码我们下面会讲解到。  

> hbx：无论什么样的资源，都是通过相同的接口进行资源访问。  

标准HTTP方法包含：GET、POST、PUT、DELETE、Patch，他们的使用功能如下列表所示
![](RESTful%20%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/1CA61FCC-F24A-4222-ADDB-5DC238D4A2D4.png)

* Get方法执行流程原理如下所示
![](RESTful%20%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/FF66E4B1-C182-435B-A009-3836E6E552C2.png)

* Put 方法执行流程图如下所示
![](RESTful%20%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/70F16349-A170-4AC6-B2D4-A5E3B21611E8.png)

* 安全性和幂等性
1、安全性：不会改变资源状态，可以理解为只读的；
2、幂等性：执行1次和执行N次，对资源状态改变的效果是等价的。
![](RESTful%20%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/%E6%88%AA%E5%B1%8F2021-09-09%20%E4%B8%8A%E5%8D%889.50.00.png)
安全性和幂等性均**不保证**反复请求能拿到相同的response。以 DELETE 为例，第一次DELETE返回200表示删除成功，第二次返回404提示资源不存在，这是允许的。

### 常见问题
* POST和PUT用于创建资源时有什么区别?
	**POST和PUT在创建资源的区别在于，所创建的资源的名称(URI)是否由客户端决定**。 例如为我的博文增加一个java的分类，生成的路径就是分类名/categories/java，那么就可以采用PUT方法。不过很多人直接把POST、GET、PUT、DELETE直接对应上CRUD，例如在一个典型的rails实现的RESTful应用中就是这么做的。
	我认为，这是因为rails默认使用服务端生成的ID作为URI的缘故，而不少人就是通过rails实践REST的，所以很容易造成这种误解。




## 2.3 资源的表述
确切的说，客户端获取的只是资源的表述而已。 资源在外界的具体呈现，可以有多种表述(或成为表现、表示)形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。 例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。
资源的表述包括：**数据**和描述数据的**元数据**，例如，HTTP头”Content-Type” 就是这样一个元数据属性

那么客户端如何知道服务端提供哪种表述形式呢?
答案是可以通过HTTP内容协商，客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。
以github为例，请求某组织资源的json格式的表述形式:
![](RESTful%20%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/39150CD3-DAC9-4909-A0E5-2C63A4C1D312.png)

* 下面我们来看一些实践上常见的设计:
	* **在URI里边带上版本号**
		有些API在URI里边带上版本号，例如:
			* http://api.example.com/1.0/foo
			* http://api.example.com/1.2/foo
			* http://api.example.com/2.0/foo
	* 	**使用URI后缀来区分表述格式**
		像rails框架，就支持使用/users.xml或/users.json来区分不同的格式。 这样的方式对于客户端来说，无疑是更为直观，但混淆了资源的名称和资源的表述形式。 我个人认为，还是应该优先使用内容协商来区分表述格式。
	* **如何处理不支持的表述格式**
		当服务器不支持所请求的表述格式，那么应该怎么办？若服务器不支持，它应
该返回一个HTTP 406响应，表示拒绝处理该请求。下面以github为例，展示了一个请求XML表述资源的结果：
![](RESTful%20%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/89B28BEB-6BCD-440C-8A2C-9A11B144F0FD.png)

## 2.4 资源的链接
我们知道REST是使用标准的HTTP方法来操作资源的，但仅仅因此就理解成带CURD的Web数据库架构就太过于简单了。
这种反模式忽略了一个核心概念：”超媒体即应用状态引擎（hypermedia as the engine of application state）”。 超媒体是什么?
当你浏览Web网页时，从一个连接跳到一个页面，再从另一个连接跳到另外一个页面，就是利用了超媒体的概念：把一个个把资源链接起来.
要达到这个目的，就要求在表述格式里边加入链接来引导客户端。在《RESTful Web Services》一书中，作者把这种具有链接的特性成为连通性。下面我们具体来看一些例子。
下面展示的是github获取某个组织下的项目列表的请求，可以看到在响应头里边增加Link头告诉客户端怎么访问下一页和最后一页的记录。 而在响应体里边，用url来链接项目所有者和项目地址。
![](RESTful%20%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/5151CB37-18A6-4CDB-B774-2C9A98E8525F.png)
又例如下面这个例子，创建订单后通过链接引导客户端如何去付款。
![](RESTful%20%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/2B3CAF03-93D9-4BE3-A101-C687C30D426D.png)


## 2.5 状态的转移
> REST原则中的无状态通信原则：这里说的无状态通信原则，并不是说客户端应用不能有状态，而是指服务端不应该保存客户端状态  

访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化；

互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”；

客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。

### 2.5.1 应用状态与资源状态
实际上，状态应该区分应用状态和资源状态，客户端负责维护应用状态，而服务端维护资源状态。
客户端与服务端的交互必须是无状态的，并在每一次请求中包含处理该请求所需的一切信息。
服务端不需要在请求间保留应用状态，只有在接受到实际请求的时候，服务端才会关注应用状态。
这种无状态通信原则，使得服务端和中介能够理解独立的请求和响应。
在多次请求中，同一客户端也不再需要依赖于同一服务器，方便实现高可扩展和高可用性的服务端。
> 	但有时候我们会做出违反无状态通信原则的设计，例如利用Cookie跟踪某个服务端会话状态，常见的像J2EE里边的JSESSIONID。  
> 这意味着，浏览器随各次请求发出去的Cookie是被用于构建会话状态的。  
> 	当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。  

### 2.5.2 应用状态的转移
状态转移到这里已经很好理解了， “会话”状态不是作为资源状态保存在服务端的，而是被客户端作为应用状态进行跟踪的。客户端应用状态在服务端提供的超媒体的指引下发生变迁。服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。
这些类似”下一页”之类的链接起的就是这种推进状态的作用——指引你如何从当前状态进入下一个可能的状态。


## RESTful接口设计规范
### 1. 动作
GET （SELECT）：从服务器检索特定资源，或资源列表。
POST （CREATE）：在服务器上创建一个新的资源。
PUT （UPDATE）：更新服务器上的资源，提供整个资源。
PATCH （UPDATE）：更新服务器上的资源，仅提供更改的属性。
DELETE （DELETE）：从服务器删除资源。

首先是四个半种动作：
post、delete、put/patch、get
因为put/patch只能算作一类，所以将patch归为半个。

另外还有有两个较少知名的HTTP动词：
HEAD - 检索有关资源的元数据，例如数据的哈希或上次更新时间。
OPTIONS - 检索关于客户端被允许对资源做什么的信息。

### 2. 路径（接口命名）
路径又称”终点”（endpoint），表示API的具体网址。

在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。

举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。

**接口尽量使用名词，禁止使用动词**，下面是一些例子。
```
GET         /zoos：列出所有动物园
POST        /zoos：新建一个动物园
GET         /zoos/ID：获取某个指定动物园的信息
PUT         /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
PATCH       /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）
DELETE      /zoos/ID：删除某个动物园
GET         /zoos/ID/animals：列出某个指定动物园的所有动物
DELETE      /zoos/ID/animals/ID：删除某个指定动物园的指定动物
```
反例：
```
/getAllCars
/createNewCar
/deleteAllRedCars
```
再比如，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。

如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：
```
POST /accounts/1/transfer/500/to/2
```
正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：
```
POST /transaction HTTP/1.1
　　Host: 127.0.0.1
　　from=1&to=2&amount=500.00
```
理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源(/school)，老师(/school/teachers)，学生(/school/students)就是二级资源。

### 3. 版本（Versioning）
应该将API的版本号放入URL。如：
```
https://api.example.com/v1/
```
另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。

### 4. 过滤信息（Filtering）
如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。
下面是一些常见的参数。
```
?limit=10：指定返回记录的数量
?offset=10：指定返回记录的开始位置。
?page_number=2&page_size=100：指定第几页，以及每页的记录数。
?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。
?animal_type_id=1：指定筛选条件
参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，
GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。
```

### 5. 状态码（Status Codes）
状态码范围
```
1xx 信息，请求收到，继续处理。范围保留用于底层HTTP的东西，你很可能永远也用不到。
2xx 成功，行为被成功地接受、理解和采纳
3xx 重定向，为了完成请求，必须进一步执行的动作
4xx 客户端错误，请求包含语法错误或者请求无法实现。范围保留用于响应客户端做出的错误，例如。他们提供不良数据或要求不存在的东西。这些请求应该是幂等的，而不是更改服务器的状态。
5xx 范围的状态码是保留给服务器端错误用的。这些错误常常是从底层的函数抛出来的，甚至
开发人员也通常没法处理，发送这类状态码的目的以确保客户端获得某种响应。
当收到5xx响应时，客户端不可能知道服务器的状态，所以这类状态码是要尽可能的避免。
```


![](RESTful%20%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/%E6%88%AA%E5%B1%8F2021-09-09%20%E4%B8%8A%E5%8D%8811.37.44.png)

![](RESTful%20%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/%E6%88%AA%E5%B1%8F2021-09-09%20%E4%B8%8A%E5%8D%8811.37.55.png)

![](RESTful%20%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/%E6%88%AA%E5%B1%8F2021-09-09%20%E4%B8%8A%E5%8D%8811.38.05.png)

![](RESTful%20%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/%E6%88%AA%E5%B1%8F2021-09-09%20%E4%B8%8A%E5%8D%8811.38.20.png)



#### 参考
[RESTful 架构详解 | 菜鸟教程](https://www.runoob.com/w3cnote/restful-architecture.html)
[restful接口设计规范总结 - 简书](https://www.jianshu.com/p/8b769356ee67)