# 二十八、连续分配管理方式（内存空间的分配与回收）

![](%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%89/B6AC89A9-AF3C-4C79-B98A-3057A5A1F485.png)

## 前言
* **内存空间的分配与回收**分为：
	* 连续分配的管理方式
	* 非连续分配的管理方式。

其中，连续分配指的是，系统为用户进程分配的必须是一个连续的内存空间。
而连续分配的管理方式又分为：
	* 单一连续分配
	* 固定分区分配
	* 动态分区分配


## 1. 单一连续分配
![](%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%89/%E6%88%AA%E5%B1%8F2021-07-05%2016.51.55.png)
在单一连续分配方式中：
	* 内存分为**系统区**和**用户区**
	* 系统区通常位于内存的低地址部分，用于存放操作系统相关数据
	* 用户区用于存放用户进程相关数据
	* **内存中永远只有一道程序，无需内存保护**（用户程序独占整个用户区空间 ）

	* 优点
		* 实现简单
		* 无外部随便
		* 可以采用覆盖技术扩充内存
		* 不一定需要采取内存保护
	* 缺点
		* 只能用于单用户、单任务的操作系统中
		* 有内部碎片（分配给某个进程or程序的内存区域中，如果有些内存的部分没有被用上，就是内部碎片）
		* 存储器利用率极低


## 2. 固定分区分配
![](%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%89/%E6%88%AA%E5%B1%8F2021-07-05%2016.59.38.png)
在出现了支持多道程序的系统时，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个**用户空间**划分为**若干个固定大小的分区**，在**每个分区中只装入一道作业**，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

* 固定分区分配可分为：
	1. 分区大小相等
		* 缺乏灵活性
		* 但是很**适合用于用一台计算机控制多个相同对象的场合**
			* （比如钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）

	2. 分区大小不等
		* 增加了灵活性，可以满足不同大小的进程需求
		* 根据常在系统中运行的作业大小情况进行划分


![](%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%89/%E6%88%AA%E5%B1%8F2021-07-05%2017.02.03.png)
* 分区说明表
	操作系统需要建立一个数据结构（分区说明表），来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的**大小、起始地址、状态（是否已经分配）**。


* 固定分区分配的优点：
	* 实现简单
	* 无外部碎片

* 缺点
	* 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能
	* 会产生**内部碎片**，内存利用率低


## 3.动态分区分配
![](%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%89/%E6%88%AA%E5%B1%8F2021-07-05%2017.26.56.png)
**动态分区分配**又称为**可变分区分配**。
这种分配方式**不会预先划分内存分区**，而是在进程装入内存时，**根据进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目时可变的。


> 1. 操作系统要用什么样的数据结构记录内存的使用情况？  
	* 两种常用的数据结构
		* 空闲分区表
		* 空闲分区链

	* 空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息
	* 空闲分区链：每个分区的起始部分和末尾部分，都会分配设置前指针和后指针。起始部分还可记录分区大小等信息。
![](%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%89/%E6%88%AA%E5%B1%8F2021-07-05%2017.33.11.png)


> 如果进程2使用完了，就会空闲出来中间的14Mb空间，那么如果又有一个4Mb的进程想进来，应该给它分配哪一段空间？  
> 2. 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？  
	把一个新作业装入内存时，需要按照一定的**动态分区分配算法**来分配。
![](%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%89/%E6%88%AA%E5%B1%8F2021-07-05%2017.34.34.png)


> 当18Mb的进程3运行完，也会空闲出来新的内存空间。那这个分区应该怎么处理，是否要与相邻的空闲分区进行合并？  
> 3.如何进行分区的分配与回收操作？  

* 分区的分配
	以空闲分区表为例：
	* 情况1:
		有一个进程5，需要4MB字节，用某种算法装入20MB的那个分区后，还剩16MB，分区数量不变，就改一下空闲分区表即可。
![](%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%89/%E6%88%AA%E5%B1%8F2021-07-05%2017.35.15.png)

	* 情况2:
	有一个进程5，需要4MB字节，用某种算法装入最后的4MB的空闲分区后，显然空闲分区的数量会减1，减去对应的表项即可。
![](%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%89/%E6%88%AA%E5%B1%8F2021-07-05%2017.38.21.png)


* 分区的回收
	
	* 情况1:
		回收区的后面有一个相邻的空闲分区，将两个相邻的空闲分区合二为一即可。

	* 情况2:
		回收区的前面有一个相邻的空闲分区，将两个相邻的空闲分区合二为一即可。

	* 情况3:
		回收区的前、后各有一个相邻的空闲分区，将三个空闲分区合并为一个即可。
	
	* 情况4：
		回收区的前、后都没有相邻的空闲分区，新增一个表项即可。

注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。


* 关于内部碎片，外部碎片的问题：
	* 动态分区**没有内部碎片**，但是**有外部碎片**

* 内部碎片，分配给某进程的内存区域中，如果有些部分没有被用上
* 外部碎片，是指内存中的某些空闲分区由于太小而难以利用
	* 可以使用**紧凑技术来解决外部碎片**
![](%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%89/D9715C9C-7420-4ADA-8AD4-9E8FCB01087F.png)

## 4. 小结
![](%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%EF%BC%89/AE5A3225-A268-48BF-8BDA-7B6AF8E41DFC.png)
