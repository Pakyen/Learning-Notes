# 二十三、哲学家进餐问题

## 问题描述
一张圆桌坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子中间是一碗饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才开始进餐，当进餐完毕后，放下筷子继续思考
![](%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98/5290FD84-0532-4697-8B63-8B9941629FD2.png)
* 关系分析：5个哲学家进程，5个哲学家与左右邻居对中间筷子的访问是互斥关系

* 这个问题与之前的问题**不同**的是，每个哲学家进程需要**同时持有两个临界资源**才能开始吃饭。如果**避免**临界资源分配不当造成的**死锁问题**，是哲学家问题的精髓

* 信号量设置：
	* 定义互斥信号量数组 chopstick[5] = {1,1,1,1,1}，实现对5个筷子的互斥访问。
	* 并对哲学家从0～4开始编号，哲学家`i`左边的筷子为`i`，右边的筷子为`(i+1)%5`
	

1. 思路一（不合理，有死锁）
	* 每个哲学家在吃饭前，都先拿起左边的筷子，上锁；拿起右边的筷子；上锁
![](%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98/%E6%88%AA%E5%B1%8F2021-04-06%2016.41.14.png)
	* 问题：如果5个哲学家**并发**地拿起了自己左边的筷子。这样的话，每个哲学家在拿起自己右边的筷子的时候就会发现没筷子了。每个哲学及哎都会循环等待右边的儿女放下筷子（阻塞），发生**死锁**

2. 思路二（对哲学家进程添加限制）（预防死锁）
	1. 方案1（最多允许4个同时进餐）
	对哲学家进程添加限制，比如**最多允许4**个哲学家同时进餐，这样可以保证**至少有一个**哲学家是可以拿到**左右两只**筷子的

	2. 方案2（奇数先拿左边再拿右边，偶数相反）
	要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子；
	要求偶数号的哲学家相反。
	这样可以保证如果相邻的两个哲学家同时想吃饭，那么**只有**有一个哲学家可以拿起**第一只筷子**，另一个会直接阻塞，这样就避免了某一个哲学家拿着一只筷子后再等待另一只筷子的情况

	3. 方案3（同时可用才拿）
	仅当一个哲学家左右两只筷子都可用时，才允许抓起筷子
```
// 方案3
semaphore chopstick[5] = {1,1,1,1,1};
semaphore mutex = 1;
Pi(){
	P(mutex);
	P(chopstick[i]);   // 拿左边筷子
	P(chopstick[(i + 1) % 5]); // 拿右边筷子
	V(mutex);
	吃饭...
	V(chopstick[i]); 			// 放下左边
	V(chopstick[(i + 1)]);		// 放下右边
	思考..
}
```