# 二十五、死锁
![](%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81/%E6%88%AA%E5%B1%8F2021-06-23%2017.55.38%202.png)

## 1. 死锁的概念
### 1.1 什么是死锁
	* 在并发环境下，各进程因竞争资源而造成的一种 ~互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进~的现象，就是「死锁」
	* 发生死锁后若无外力干涉，这些进程都将无法向前推进

### 1.2 死锁、饥饿、死循环的区别
	* **死锁**：
		* 并发时，各进程都互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象
	* **饥饿**：
		* 长期得不到想要的资源，导致进程无法向前推进的现象。例如短进程优先算法中，长进程可能一直得不到资源，所以会发生长进程“饥饿”。
	* **死循环**：
		* 某进程执行的过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的
![](%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81/040156E0-0949-46FE-9850-14A4E2F6D4E3%202.png)


### 1.3 死锁产生的必要条件
* 关键：只要四个必要条件中有一个不成立，死锁就不会发生！

	* **互斥条件**：必须对互斥的资源进行竞争抢夺才会可能导致死锁现象的发生。
	
	* **不剥夺条件**：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
	
	* **请求和保持条件**： ~对已经占有的资源不释放~ ， ~又提出了新的资源请求~ ，此时发生了进程阻塞，但是还不释放自己已经占有的资源。
	
	* **循环等待条件**：存在一条进程资源的循环等待链，链中的每一个进程已经获得的资源同时被下一个进程所请求。

> 注意，发生死锁的时候一定有循环等待。但是发生循环等待时未必发生死锁  

### 1.4 什么时候会发生死锁？

> 总而言之一句话：对不可剥夺的资源的不合理分配，可能导致死锁。  

具体可以有以下几种情况：
1. **对系统资源的竞争**。各个进程对不可剥夺的资源的竞争（如打印机）可能引起死锁；对可剥夺的资源(CPU)的竞争是不会引起死锁的

2. **进程推进顺序非法**。请求和释放资源的顺序不当，也同样可能会导致死锁；

3. 信号量的使用不当也可能造成死锁，例如在pv操作中，实现互斥的p操作在实现同步的p操作之前，可能会导致死锁。


## 2. 死锁的处理策略
> 1. **预防死锁**： 破坏死锁产生的四个必要条件中的一个或几个。（互斥条件、不剥夺条件、请求和保持条件、循环等待条件）  
>   
> 2. **避免死锁**： 用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）  
>   
> 3. **死锁的检测和解除**： 允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁  


### 2.1 死锁的处理策略——预防死锁
![](%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81/%E6%88%AA%E5%B1%8F2021-06-23%2023.59.45.png)
预防死锁就是破坏死锁的四个必要条件（一个或几个）
	* 破坏互斥条件
		* 把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。
			* 如SPOOLing技术，可以将独占设备在逻辑上改造成共享设备
		* 缺点：
			* 并不是所有的资源都可以改造成可共享使用的资源。
			* 并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件


	* 破坏不剥夺条件
		* 方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不剥夺条件。
		* 方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，也就是将处理机资源强行剥夺给优先级更高的进程使用）

		* 该策略的缺点：
			* 实现起来比较复杂
			* 释放已获得资源可能造成前一阶段工作的实效。因此这种方式一般只适用于易保存和恢复状态的资源，如CPU
			* 反复地深情和释放资源汇增加系统开销，降低系统吞吐量
			* 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿


	* 破坏请求和保持条件
		* 采用静态分配方法：即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。这些资源就一直归它所有，该进程就不会再请求别的任何资源了。
		* 缺点
			* 有些资源只使用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也可能会导致某些进程饥饿
			

	* 破坏循环等待条件
> **循环等待条件**：存在一条进程资源的循环等待链，链中的每一个进程已经获得的资源同时被下一个进程所请求。  
		* 采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按照编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。
			* 原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大的编号资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。
![](%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81/%E6%88%AA%E5%B1%8F2021-06-23%2023.55.51.png)
		* 缺点：
			* 不方便增加新的设备，因为可能需要重新分配所有的编号
			* 进程实际使用的资源的顺序可能和编号递增的顺序不一致，会造成资源的浪费。（比如P3进程实际需要先使用7号资源，再使用5号资源，但是由于编号递增的要求，P3就只能先占有暂时用不到的5号资源，就造成了5号资源的长时间空闲，造成了资源的浪费
			* 必须按照规定次序申请资源，用户编程麻烦


### 2.2 死锁的处理策略——避免死锁
![](%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81/%E6%88%AA%E5%B1%8F2021-06-24%2012.30.56.png)
1. 什么是安全序列
	如果系统安装这种序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列，系统就是**安全状态**。当然，**安全序列可能有多个**。

2. 什么是系统的不安全状态，与死锁有何联系
	如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还一些资源，系统也有可能重新回到安全状态，不过我们在分配资源之前总是考虑到最坏的情况。
	如果系统处于**安全状态**，就**一定不会**发生**死锁**。如果系统进入**不安全状态**，系统未必发生死锁。但发生死锁一定是在不安全状态。

3. 如何避免系统进入不安全状态——**银行家算法**
	因此可以**在资源分配之前预先判断这次分配是否导致系统进入不安全状态**，以此决定是否答应资源分配请求，“**银行家算法**”的核心思想。

> 银行家算法是Dijkstra为银行系统设计的，为的是确保银行在发生现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于**避免死锁**  

* **核心思想**：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

* e.g.
![](%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81/%E6%88%AA%E5%B1%8F2021-06-24%2013.15.26.png)
> P0最多还需要 > (3,3,2)  
> P1最多还需要 <= (3,3,2).可分配，执行结束，获取已分配资源(2,0,0) + (3,3,2) = (5,3,2)  
> P0最多还需要 > (5,3,2)  
> P2最大还需要 > (5,3,2)  
> P3最大还需要 (2,1,1)<= (5,3,2) 可分配，执行结束，获取已分配资源 (2,1,1) + (5,3,2) = (7,4,3)  
> 之后所有都为安全序列  
> 思路：尝试找到一个安全序列… {P1,P3,P0,P2,P4}  

![](%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81/7276A7EE-ED7F-4769-8DFE-834C3DD8BA07.png)

每个进程发出请求为Request矩阵
可用**银行家算法**预判本次分配是否会导致系统进入不安全状态：
①. 如果Request[j] <= Need[i,j] (0 <= j <= m)便转向②；否则认为出错。
②.如果Request[j] <= Available[j] (0 <= j <= m)便转向③；否则表示尚无足够资源，Pi必须等待。
③.系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）.
④.操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相同数据，让进程阻塞等待。

* 小结
	* 银行家算法步骤
		1. 检查此次申请是否超过了之前声明的**最大需求数**
		2. 检查此时系统**剩余的可用资源**是否还能满足这次请求
		3. 试探着**分配**，更改各数据结构
		4. 用安全性算法检查此次分配是否会导致系统进入不安全状态

	* 安全性算法步骤：
		检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收
		不断重复上述过程，看最终是否能让所有进程都加入安全序列


### 2.3 死锁的处理策略——检测和解除
![](%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81/%E6%88%AA%E5%B1%8F2021-06-24%2014.53.22.png)

#### 2.3.1 死锁的检测
用于检测系统状态，以确定系统中是否发生了死锁。
①用**某种数据结构**（资源分配图）来保存资源的请求和分配信息；
②提供**一种算法**，利用上述信息来检测系统是否已进入死锁状态。
1. 资源分配图
![](%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81/%E6%88%AA%E5%B1%8F2021-06-24%2015.00.24.png)
![](%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81/%E6%88%AA%E5%B1%8F2021-06-24%2015.07.42.png)

如果系统剩余的可用资源数满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这些可能又会激活另外一些阻塞的己进程…


如果按上述过程分析，**最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁**（相当于能找到一个安全序列）

~如果最终不能消除所有边，那么此时就是发生了死锁~
**死锁定理**：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁

#### 2.3.2 死锁的解除
当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。

1. **资源剥夺法**。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。
2. **撤销进程法**（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，可能导致已经运行很长时间的进程，直接结束。
3. **进程回退法**。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。


