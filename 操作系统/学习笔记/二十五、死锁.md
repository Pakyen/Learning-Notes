# 二十五、死锁
![](%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81/%E6%88%AA%E5%B1%8F2021-06-23%2017.55.38.png)

## 1. 死锁的概念
### 1.1 什么是死锁
	* 在并发环境下，各进程因竞争资源而造成的一种 ~互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进~的现象，就是「死锁」
	* 发生死锁后若无外力干涉，这些进程都将无法向前推进

### 1.2 死锁、饥饿、死循环的区别
	* **死锁**：
		* 并发时，各进程都互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象
	* **饥饿**：
		* 长期得不到想要的资源，导致进程无法向前推进的现象。例如短进程优先算法中，长进程可能一直得不到资源，所以会发生长进程“饥饿”。
	* **死循环**：
		* 某进程执行的过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的
![](%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81/040156E0-0949-46FE-9850-14A4E2F6D4E3.png)


### 1.3 死锁产生的必要条件
* 关键：只要四个必要条件中有一个不成立，死锁就不会发生！

	* **互斥条件**：必须对互斥的资源进行竞争抢夺才会可能导致死锁现象的发生。
	
	* **不剥夺条件**：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
	
	* **请求和保持条件**： ~对已经占有的资源不释放~ ， ~又提出了新的资源请求~ ，此时发生了进程阻塞，但是还不释放自己已经占有的资源。
	
	* **循环等待条件**：存在一条进程资源的循环等待链，链中的每一个进程已经获得的资源同时被下一个进程所请求。

> 注意，发生死锁的时候一定有循环等待。但是发生循环等待时未必发生死锁  

### 1.4 什么时候会发生死锁？

> 总而言之一句话：对不可剥夺的资源的不合理分配，可能导致死锁。  

具体可以有以下几种情况：
1. **对系统资源的竞争**。各个进程对不可剥夺的资源的竞争（如打印机）可能引起死锁；对可剥夺的资源(CPU)的竞争是不会引起死锁的

2. **进程推进顺序非法**。请求和释放资源的顺序不当，也同样可能会导致死锁；

3. 信号量的使用不当也可能造成死锁，例如在pv操作中，实现互斥的p操作在实现同步的p操作之前，可能会导致死锁。


## 2. 死锁的处理策略
> 1. **预防死锁**： 破坏死锁产生的四个必要条件中的一个或几个。（互斥条件、不剥夺条件、请求和保持条件、循环等待条件）  
>   
> 2. **避免死锁**： 用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）  
>   
> 3. **死锁的检测和解除**： 允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁  


### 2.1 死锁的处理策略——预防死锁
预防死锁就是破坏死锁的四个必要条件（一个或几个）
	* 破坏互斥条件
		* 把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。
			* 如SPOOLing技术，可以将独占设备在逻辑上改造成共享设备
		* 缺点：
			* 并不是所有的资源都可以改造成可共享使用的资源。
			* 并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件
	* 破坏不剥夺条件
		* 方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不剥夺条件。
		* 方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，也就是将处理机资源强行剥夺给优先级更高的进程使用）
		* 
### 2.2 死锁的处理策略——避免死锁


### 2.3 死锁的处理策略——检测和解除


