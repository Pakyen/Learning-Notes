# 三十、非连续分配管理方式之基本分页存储管理的基本概念

> 在内存空间的分配与回收中，有**连续分配的管理方式**（单一连续分配、固定分区分配、  
> 动态分区分配）和**非连续的分配管理方式**  
>   
> 其中单一连续分配是只能用于单道程序，而支持多道程序的固定分区分配（缺乏灵活性，会产生大量内部碎片，内存的利用率很低）和动态分区分配（会产生很多外部碎片，虽然可以用“紧凑”技术来处理，但是“紧凑的时间代价很高”）  
>   ![](%E4%B8%89%E5%8D%81%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E6%88%AA%E5%B1%8F2021-07-09%2015.01.58.png)  
> 所以就有了非连续分配的管理方式  

## 0. 非连续分配管理方式
![](%E4%B8%89%E5%8D%81%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/DF13A446-7441-49A1-8ABF-18D935A15EF5.png)
非连续分配管理方式分为：
	* **基本分页存储管理**
	* **基本分段存储管理**
	* **段页式存储管理**

## 1. 基本分页存储管理

### 1.1 基本分页存储管理的基本概念
基本分页存储管理的思想：
	**把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分**

每个分区就是一个（可以叫作一个）：
	* 页框
	* 页帧
	* 内存块
	* 物理块

每个页框有一个编号（可以叫作）：
	* 页框号
	* 页帧号
	* 内存块号
	* 物理块号

页框号**从0开始**

将用户进程的地址空间也分为**与页框大小相等**的一个个区域，称为**“页”**或**“页面”**。每个页面也有一个编号，即**“页号”**，页号也是**从0开始**

（注：进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）
![](%E4%B8%89%E5%8D%81%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/70A21600-A4D6-4261-B076-269E049781BD.png)


### 1.2 采用分页技术后的地址转换
![](%E4%B8%89%E5%8D%81%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/A5EB965B-093E-4617-BD6A-CE06871DCF8B.png)
首先将进程的逻辑地址进行分页，假设每一个页面的大小为50字节，被不连续地放到内存的物理地址中

如果这时候有一个CPU指令，需要访问逻辑地址为80的内存单元，如何转化为物理地址？
根据上图可以知道逻辑地址为80的位置，在1号页内，1号页在内存中的起始位置为450，逻辑地址80相对于该页的起始位置(50)而言，偏移量为30
所以逻辑地址80对应的实际物理地址 = 450 + 30 = 480

所以，在分页存储管理中的地址转换：
	1. 算出逻辑地址对应的**页号**
	2. 要知道该页号对应**页面在内存中的起始地址**
	3. 算出逻辑地址**在页面内的“偏移量”**
	4. **物理地址 = 页面起始地址+ 页内偏移量**


### 1.3 页表
为了能知道进程的每个页面在内存中存放的位置，操作系统要为**每一个进程建立一张页表**
![](%E4%B8%89%E5%8D%81%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/05739ED1-A7B5-4CE9-B6A9-8253A10DE099.png)

### 1.4 基本分页存储管理小结
![](%E4%B8%89%E5%8D%81%E3%80%81%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1DA8A255-962C-4C2D-833B-C9C1817B8073.png)







