# 十六、进程互斥的实现算法（软件）与硬件实现
![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2010.56.05.png)
![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2011.37.35.png)

![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2011.42.32.png)
![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2012.10.07.png)

 
## 1. 进程互斥的软件实现算法
### 1.1 单标志法
	* 算法思想：
	两个进程在会把使用临界区的权限转交给另一个进程，也就是说**每个进程进入临界区的权限只能被另一个进程赋予**

![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2011.00.27.png)
![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2011.02.06.png)

单标志法实现了互斥，可以实现“同一时刻最多只允许一个进程访问临界区”；

	* 缺点：
		违背了“空闲让进原则”。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是 P0，而P0一直不访问临界区，那么久不会将turn改为1，P1久没发访问临界区


### 1.2 双标志先检查法

	* 算法思想：
		* 设置一个布尔型数组flag[]，数组中各个元素用来**标记各进程想进入临界区的意愿**，比如"flag[0]=True"意味着0号进程 P0现在想要进入临界区。
		* 每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设置为True，之后开始访问临界区；
![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2011.07.24.png)

	* 缺点：
		* **违背了 “忙则等待” 原则**
> 	该方法的问题时，两个进程是并发执行的（问题：异步性）；  
> 	  
> 	如果P0和P1在执行的过程中发生了切换，假设刚开始P0运行，首先执行（1），发现flag[1]为false，进入语句（2），但是在执行（2）之前，恰好发生了进程切换，切换到P1，P1执行（5）；此时flag[0]=false，循环跳出；由于是**并发执行**，这时又跳回了P0，继续执行（2），设置flag[0] = true；此时P0又切换到P1，执行（6），设置flage[1] = true；  
> 	也就是如果按照（1）（5）（2）（6）（3）（7）这样的循序执行，P0和P1有可能同时访问临界区。所以这样就违背了进程互斥最基本的原则，“忙则等待”。这种情况下，当一个进程在访问临界区的时候，另一个进程也有可能访问了临界区，就不互斥了  

	* 问题在于：**进入区**的“检查”和“上锁”**两个处理不是一气呵成的**。
		“检查”后，“上锁”前可能发生进程切换；这两个操作不是一个原子操作
![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2011.20.12.png)


### 1.3 双标志后检查法

	* 算法思想：
		**双标志后检查法** 是 双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法来避免上述问题；

![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2011.22.49.png)

	* 缺陷：虽然**解决了 “忙则等待”** 的问题，但是**又违背了 “空闲让进” 和 “有限等待”**，会因为各进程都长期无法访问临界资源而**产生 “饥饿”**现象

> 如果按照（1）（5）（2）（6）的顺序执行，P0和P1都无法进入临界区  

#### 分析：
以上三个方法的问题，全都是由于并发执行的时候，进程的异步性导致的


### 1.4 Peterson算法（皮特森算法）

	* 算法思想：
		双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Peterson想到了一种方法，**如果双方都争着想进入临界区**，那可以让进程尝试“孔融让梨”，**主动让对方先使用临界区**
![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2011.29.33.png)

> 双标志先检查法 和 双标志后检查法 的问题都是，因为 进入区的几个操作不能一气呵成 导致的  

皮特森算法的进入区：
	1. 主动争取，flag[0] = true
	2. 主动谦让， turn = 1
	3. 检查对方是否也想用，如果对方也想用，就循环等待

> 如果两个人同时谦让也没关系[（1）（6）（2）（7）（8）]，因为在最后一次检查的时候，P1将turn从1改为0，让P0使用了  

* 优点：
	* 遵**循了空闲让进、忙则等待、优先等待 三个原则**
* 缺点：
	* **没有**遵循**让权等待的原则**，还是会忙等待

### 1.5 小结
![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2011.37.35%202.png)



## 2. 进程互斥的硬件实现方法
![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2011.42.32%202.png)

### 2.1 中断屏蔽方法
![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2011.45.15.png)
**关中断后不允许当前进程被中断，也必然不会发生进程切换。**
**开中断知道当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区**
**开中断和关中断只运行在内核态**


### 2.2 TestAndSet指令（TS/TSL）

简称TS指令，也叫做TestAndSetLock , TSL

TSL指令**用硬件实现的**，执行的过程不允许被中断，只能一气呵成
![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2012.07.20.png)


### 2.3 Swap指令（XCHG）

有的地方交Exchange指令，或简称XCHG指令

Swap指令**是用硬件实现的**，执行的过程不允许被中断，只能一气呵成

![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2012.09.08.png)



### 2.4 小结
![](%E5%8D%81%E5%85%AD%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%EF%BC%88%E8%BD%AF%E4%BB%B6%EF%BC%89%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0/%E6%88%AA%E5%B1%8F2021-04-03%2012.10.07%202.png)


















