# 二十二、读者-写者问题

## 问题描述
	* 读者和写者两组并发进程，共享一个文件
	* **允许多个读者进程同时访问共享数据**
	* **写进程不能和其他进程同时访问共享数据（读进程和写进程）**（只允许一个写进程往文件中写信息）
	* **任一写者在完成写操作之前不允许其他读者或写者工作**
	* **写者执行写操作之前，应已有读者和写者全部退出。**

* 与消费者进程不同，消费者读数据的同时会取走数据，而读进程只是读数据，不会改变数据或将数据清空，所以多个读者可以同时访问共享数据
* 两个写进程同时共享数据，可能导致数据错误覆盖的问题
* 写进程与读进程同时共享数据，可能导致读出的数据不一致的问题

![](%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/%E6%88%AA%E5%B1%8F2021-04-06%2014.29.29.png)

* 两类进程：写进程、读进程。
* 互斥关系：写写互斥，读写互斥。
* **写进程与其他进程互斥**所以定义一个rw互斥信号量。


1. 算法一（信号量rw）
![](%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/%E6%88%AA%E5%B1%8F2021-04-06%2014.39.13.png)
* 第一个算法的潜在问题：
	如果第一个读进程，判断count==0，要进行P(rw)操作。而在进行P(rw)操作之前，切换到了第二个读进程，此时count==0，第二个进程也要进行P(rw)操作。于是两个先后运行的并发读进程进行P(rw)，那么就有一个读进程成功通过P(rw)，第二个进程会在if语句里被阻塞.

	导致该问题的原因是：count变量的检查和赋值不是一气呵成的。


2. 算法二（信号量rw，和信号量mutex）

可以通过设置另一个信号量mutex，保证对count的互斥访问
![](%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/14657648-9CA1-4D3A-AB42-5C25D18C70DC.png)

* 第二个算法的潜在问题：只要读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法是读进程优先的。


3. 算法三（信号量rw，信号量mutex，信号量w）（读写公平）
![](%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/%E6%88%AA%E5%B1%8F2021-04-06%2014.52.05.png)
假设是 读者 -> 写者 -> 读者，
那么读者读文件前执行完了v(w)操作，写者可以进行P(w)操作（虽然会被阻塞在P(rw)操作，因为读进程的P(w)和V(w)之间进行了P(rw)）。如果有新的读进程到达，因为写者已经进行了P(w)操作，所以新的读进程会被阻塞在P(w)处，不会插队。等到第一个读进程读完后count-1后等于0，执行了V(rw)操作。写进程就可以继续执行了，不会被“饿死”


