# 线程状态概述

## 线程状态概述
当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢?在API中`java.lang.Thread.State` 这个枚举中给出了::六种线程状态:::
![](%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A6%82%E8%BF%B0/%E6%88%AA%E5%B1%8F2021-03-04%2011.31.02.png)
> 首先在new一个Thread()，或new一个Thread子类()时，线程处于::NEW 新建状态::；  
> new完之后，可能new了多个线程，一起抢夺cpu的执行权。谁抢到了，就进入::RUNNABLE 运行状态::，没抢到的进入::BLOCKED 阻塞状态::（阻塞状态和运行状态时可以互相转换），当线程（1. 执行完run()方法 2. 调用了stop()方法 3.或线程产生了异常）就会进入到::TERMINATED 死亡状态::；  
> 如果在运行时调用了sleep(long)方法或wait(long)方法，线程就会从运行状态进入::TIME_WAITTING 休眠状态::，也叫作::计时等待::，睡醒之后，如果cpu空闲就进入运行状态; cpu不空闲就进入阻塞状态等待；  
> 如果在运行状态使用了无参数的 Object.wait()方法，那么进程就会进入::WAITTING 无限等待状态::，也叫作植物人状态或永久等待状态；如果要唤醒无限等待状态的进程，就要使用 Object.notify() 方法（cpu空闲 -> RUNNABLE；cpu不空闲 -> BLOCKED）  
> 另外，休眠状态和无限等待状态是由区别的，休眠状态可以醒的，无限等待状态只能通过调用方法来唤醒  
> 睡眠状态和无限等待状态也称作为冻结状态  
![](%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A6%82%E8%BF%B0/%E6%88%AA%E5%B1%8F2021-03-04%2011.30.19.png)

