# 等待唤醒分析

> 我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几 个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable(可运行)状态与非运行状态之间 的转换问题  



## Timed Waiting(计时等待)
注意事项：

1. 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。
2. 为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠
3. sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable(可运行)状态。

> 小提示:sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。  
![](%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E5%88%86%E6%9E%90/%E6%88%AA%E5%B1%8F2021-03-04%2011.33.32.png)

## BLOCKED（锁阻塞）
> Blocked状态在API中的介绍为:一个正在阻塞等待一个监视器锁(锁对象)的线程处于这一状态。 我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。 这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态  

![](%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E5%88%86%E6%9E%90/%E6%88%AA%E5%B1%8F2021-03-04%2011.37.04.png)


## Waiting（无限等待）
> Wating状态在API中介绍为:一个正在无限期等待另一个线程执行一个特别的(唤醒)动作的线程处于这一状态  

> 其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系， 多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞 争，但更多时候你们更多是一起合作以完成某些任务。  
> 当多个线程协作时，比如A，B线程，如果A线程在Runnable(可运行)状态中调用了wait()方法那么A线程就进入 了Waiting(无限等待)状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了 notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入 Runnable(可运行)状态;如果没有获取锁对象，那么就进入到Blocked(锁阻塞状态)。  
![](%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E5%88%86%E6%9E%90/%E6%88%AA%E5%B1%8F2021-03-04%2011.46.00.png)

## Summary

![](%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E5%88%86%E6%9E%90/%E6%88%AA%E5%B1%8F2021-03-04%2011.46.30.png)


> 我们在翻阅API的时候会发现Timed Waiting(计时等待) 与 Waiting(无限等待) 状态联系还是很紧密的， 比如Waiting(无限等待) 状态中wait方法是空参的，而timed waiting(计时等待) 中wait方法是带参的。 这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是 如果提前得到(唤醒)通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两 得。如果没有得到(唤醒)通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来;如果在倒 计时期间得到(唤醒)通知，那么线程从Timed Waiting状态立刻唤醒。  



## 等待唤醒实例
<a href='Demo01WaitAndNotify(1).java'>Demo01WaitAndNotify(1).java</a>
等待唤醒案例:线程之间的通信
	创建一个顾客线程(消费者):告知老板要的包子的种类和数量,调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)
	创建一个老板线程(生产者):花了5秒做包子,做好包子之后,调用notify方法,唤醒顾客吃包子

* 注意:
	* 顾客和老板线程必须使用同步代码块包裹起来,保证等待和唤醒只能有一个在执行
	* 同步使用的锁对象必须保证唯一
	* 只有锁对象才能调用wait和notify方法

## Object类中的wait带参数方法和notifyall()方法
<a href='Demo02WaitAndNotify.java'>Demo02WaitAndNotify.java</a>
* 进入到TimeWaiting(计时等待)有两种方式
	1. 使用sleep(long m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态
	2. 使用wait(long m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到Runnable/Blocked状态

    * 唤醒的方法:
	void notify() 唤醒在此对象监视器上等待的单个线程。
	void notifyAll() 唤醒在此对象监视器上等待的所有线程。








