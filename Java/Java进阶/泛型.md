# 泛型

## 泛型概述
> 在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。  

> 泛型其实可以看成一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型  
> 泛型也可以看作一个变量，用来接收数据类型  
![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2011.19.07.png)
> 查看ArrayList源码，也会发现它在定义的时候使用的是泛型E，创建集合对象的时候，才会确定泛型的数据类型  
![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2011.23.45.png)

## 使用泛型的好处
* 创建集合对象，如果**不使用泛型**，有好处也有坏处
	* 好处：集合不使用泛型，默认的类型就是Object类型，可以存储任意类型的数据
	* 弊端：不安全，会引发异常
> 比如往集合内添加字符串和整型数字，类型不一样（由于集合没有做任何限定，所以任何类型都可以存放）  
> 我们可以使用迭代器遍历，取出的元素也都是Object类型  
> 但是如果我们想要使用String类特有的方法，如Length获取字符串的长度，就不能使用了；因为这是多态，Object obj = “abc”，多态不能使用子类特有的方法，需要向下转型，将Object转成字符串【但会报类型转换异常，因为不能把Integer转为字符串】  
![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2011.35.39.png)


* 创建**集合**对象，::使用泛型::
	* 好处：
		1. ::避免了类型转换的麻烦::，存储的是什么类型，取出的就是什么类型
		2. 把运行期异常（运行之后会抛出的异常），提升到了编译器（写代码的时候会报错）
			* 将运行时期的ClassCastException，转移到了编译时期变成了编译失败
![](%E6%B3%9B%E5%9E%8B/3F49806A-85BE-4988-B829-F5B69D686CDA.png)
	* 弊端：
		* 泛型是什么类型，只能存储什么类型的数据

![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2011.38.12.png)

## 泛型的定义与使用
* 我们在集合中会大量使用到泛型，这里来完整地学习泛型知识
* 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递
### 定义和使用含有泛型的类
* 定义格式
	`修饰符 class 类名<代表泛型的变量> {  }`
![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2012.01.41.png)
* 在创建对象的时候确定泛型
	`ArrayList<String> list = new ArrayList<String>();`
![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2012.02.42.png)

### 定义和使用含有泛型的方法
泛型定义在方法的修饰符和返回值类型之间
* 定义格式：
	`修饰符 <代表泛型的变量> 返回值类型 方法名(参数){  }`
![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2012.07.18.png)
这里<MVP>表示代表泛型的变量，什么字母都可以

* 使用格式：
![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2012.10.18.png)

### 含有泛型的接口
* 定义格式：
`修饰符 interface接口名<代表泛型的变量> {  }`
![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2012.13.08.png)

* 使用格式
	1. 定义类时确定泛型的类型
![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2012.13.44.png)

	2. 始终不确定泛型的类型，直到创建对象时，确定泛型的类型
![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2012.14.43.png)
![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2012.15.00.png)

## 泛型通配符
当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符<?>表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用

### 通配符基本使用
* 泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?, ?表示未知通配符
* 此时只能接受数据,不能往该集合中存储数据
![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2012.19.12.png)

### 通配符高级使用 —— 受限泛型
之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置
但是在JAVA的泛型中可以指定一个泛型的**上限**和**下限**

* 泛型的上限
	* 格式 `类型名称 <? extends 类 > 对象名称`
	* 意义：只能接受该类型及其子类

* 泛型的下限
	* 格式 `类型名称 <? super 类 > 对象名称`
	* 意义：只能接受该类型及其父类

比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类
![](%E6%B3%9B%E5%9E%8B/%E6%88%AA%E5%B1%8F2021-02-25%2012.24.02.png)

