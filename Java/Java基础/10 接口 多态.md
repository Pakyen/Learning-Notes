# 10 接口 多态

##  10.1 接口的定义基本格式
	* 接口就是多个类的公共规范
	* 接口是一种引用数据类型
	* (接口实际上是给不同的类定义相同的方法）
	* 定义一个接口的格式:
```
		public interface 接口名称{
				//接口内容
		}
```
如果是Java 7，那么接口中可以包含的内容有：
	1. 常量
	2. 抽象方法

如果是Java 8，还可以额外包含有：
	3. 默认方法
	4. 静态方法

如果是Java 9，还可以额外包含有：
	5. 私有方法
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-18%2010.43.06.png)
## 10.2 接口的抽象方法定义
在任何版本的Java中，接口都能定义抽象方法
public abstract 返回值类型 方法名称（参数列表）

注意事项：
	1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract
	2. 这两个关键字修饰符，可以选择性地省略（不推荐）
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-18%2010.17.28.png)
	3. 方法的三要素可以随意定义

## 10.3 接口的抽象方法使用
接口的使用步骤
	1. 接口不能直接使用，必须有一个“实现类”来“实现”该接口
	 格式：public class 实现类名称 implements 接口名称 {…}

	2. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法：
	 实现：去掉abstract关键字，加上方法体大括号

	3. 创建实现类的对象，进行使用

注意事项：
	如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类

## 10.4 接口的默认方法定义
请查看：[浅谈JAVA8引入的接口默认方法_行者-CSDN博客](https://blog.csdn.net/wanghao_0206/article/details/52712736)

从Java8开始，接口里允许定义默认方法
格式：
```
public default 返回值类型 方法名称（参数列表）{
		方法体
}	
```
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-18%2010.44.14.png)
ps: 接口当中的默认方法，可以解决接口升级的问题
- - - -
在JDK8之前，接口不能定义任何实现，这意味着之前所有的JAVA版本中，接口制定的方法是抽象的，不包含方法体。从JKD8开始，添加了一种新功能-默认方法。默认方法允许接口方法定义默认实现，而所有子类都将拥有该方法及实现。

默认方法的优势：
	1. 默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。加入我们有一个已经投入使用接口需要拓展一个新的方法， ~在JDK8以前，如果为一个使用的接口增加一个新方法，则我们必须在所有实现类中添加该方法的实现，否则编译会出现异常~ 。如果实现类数量少并且我们有权限修改，可能会工作量相对较少。 ~如果实现类比较多或者我们没有权限修改实现类源代码~ ，这样可能就比较麻烦。 ~而默认方法则解决了这个问题，它提供了一个实现，当没有显示提供其他实现时就采用这个实现。这样新添加的方法将不会破坏现有代码~ 。

	2. ~默认方法的另一个优势是该方法是可选的~ ，子类可以根据不同的需求Override默认实现。例如，我们定义一个集合接口，其中有增、删、改等操作。如果我们的实现类90%都是以数组保存数据，那么我们可以定义针对这些方法给出默认实现，而对于其他非数组集合或者有其他类似业务，可以选择性复写接口中默认方法。( ~由于接口不允许有成员变量，所以本示例旨在说明默认方法的优势，并不具有生产可能性~ )具体参照如下代码：
```
    /**
     * 定义接口，并包含默认实现方法
    */
    public interface CollectionDemoInter {
    //增加默认实现
    default void addOneObj(Object object){
        System.out.println("default add");
    }
    //删除默认实现
    default void delOneObj(Object object){
        System.out.println("default del");
    }
    //更新默认实现
    default void updateOneObj(Object object){
        System.out.println("default del");
    }
    //接口定义需要实现方法
    String showMsg();
}
```
通过上述代码，大家可以很清楚的发现，如果在接口中定义默认方法，则子类不需要必须实现该默认实现，如果有特殊需求或者需要，则可以Override该实现。还有一种情形， ~如果一个类实现两个或两个以上接口，并且多个接口中包含统一默认方法，此时，编译器将报错。这种情况，我们必须让子类Override该方法，否则无法编译通过~ 。

## 10.5 接口的默认方法使用
	1. 接口的默认方法，可以通过接口实现类对象，直接调用
	2. 接口的默认方法，也可以被接口实现类进行覆盖重写  

## 10.6 接口的静态方法定义
从Java8开始，接口当中允许定义静态方法
格式：
```
	public static 返回值类型 方法名称（参数列表）{
		方法体
	}
```
ps: 就是将abstract或者default换成static即可，带上方法体

## 10.7 接口的静态方法使用
	1. 不能通过接口实现类的对象来调用接口当中的静态方法
	「一个类可以实现多个接口，这么多个接口当中，静态方法有可能会产生冲突，所以不行」

	2. 正确用法：
	通过接口名称直接调用其中的静态方法「接口名称.静态方法名(参数);」
- - - -
关于静态方法：
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-18%2011.53.17.png)
1:方便使用
2:不用实例化
3:被预编译
4:提前划分了内存空间，访问速度更快
5:多了也不好,还没用就占了空间

## 10.8 接口的私有方法定义
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-18%2011.20.56.png)
解决方案：
从Java9开始，接口当中允许定义私有方法
	1. 普通私有方法，解决多个默认方法之间重复代码问题
    格式：
		private 返回值类型 方法名称(参数列表){…}
	3. 静态私有方法，解决多个静态方法之间重复代码问题
	 格式：
		private static 返回值类型 方法名称(参数列表){…}

## 10.9 接口的私有方法使用
java9才支持，从Java9开始，接口当中才允许定义私有方法，来解决多个方法中重复代码的问题
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/78464F39-7790-42D7-A5C0-884629085BE2.png)

## 10.10 接口的常量定义和使用
* 接口当中也可以定义“成员变量”，但是必须使用pubic static final三个关键字进行修饰。从效果上看，这其实就是接口的【常量】

* 格式：
	public static final 数据类型 常量名称 = 数据值；
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/A478220E-D2EE-4829-ACB1-2AC62E97EEC1.png)

* 注意：一旦使用final关键字进行修饰，说明不可改变

1. 接口当中的常量，可以省略public static final，（不过不写也照样是这三个关键字）
2. 接口当中的常量，必须进行赋值，不能不赋值
3. 接口中，常量的名称使用完全大写的字母，且用下划线分隔（推荐命名规则）

## 10.11 接口的内容小结
在Java9+版本中，接口的内容可以有：

	1. 成员变量其实是常量，格式：
	`[public] [static] [final] 数据类型 常量名称 = 数据值`
	注意：
		* 常量必须进行赋值，而且一旦赋值不能改变
		* 常量名称完全大写，用下划线进行分隔

	2. 接口中最重要的就是抽象方法，格式:
	`public abstract 返回值类型 方法名称(参数列表);`
	注意：
		* 实现类必须覆盖重写接口的所有抽象方法，除非实现类是抽象类

	3. 从Java8开始，接口里允许定义默认方法，格式：
	`[public] default 返回值类型 方法名称(参数列表){方法体}; `
	注意：
		* 默认方法也可以被覆盖重写

	4. 从Java8开始，接口里允许定义静态方法，格式：
	`[public] static 返回值类型 方法名称(参数列表){方法体};`
	注意：
		* 接口的静态方法必须通过接口名称进行调用，不能通过实现类对象调用接口静态方法
	
	5. 从Java9开始，接口里允许定义私有方法，格式：
	* 普通私有方法：
		`private 返回值类型 方法名称(参数列表){方法体}`
	* 静态私有方法
		`private static 返回值类型 方法名称(参数列表){方法体}`
	* 注意：private方法只有接口自己才能调用，不能被实现类或者别人使用

## 10.12 使用接口的注意事项
	1. 接口是没有静态代码块或者构造方法的
	2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口
	`public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB{覆盖重写所有抽象方法}`
	3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可
	4. 如果实现类没有覆盖所有接口当中的所有抽象方法，那么实现类必须是一个抽象类
	5. 如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类就一定要对重复的默认方法进行覆盖重写（重写一次即可）
	6. 如果类同时继承父类，并实现了多个接口，而且父类和接口中有相同的方法（接口的默认方法），优先使用父类当中的方法【在Java中，继承的优先级>接口】
父类：
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-18%2012.13.12.png)

接口：
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-18%2012.13.54.png)

子类，继承父类同时实现接口：
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-18%2012.15.16.png)

创建子类对象，并调用重名的method方法，查看子类使用的是父类的还是接口的默认方法：
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-18%2012.14.51.png)
结果：
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-18%2012.15.05.png)

## 10.13 接口之间的多继承
	1. 类与类之间是单继承的，直接父类只有一个
	2. 类与接口之间是多实现的，一个类可以实现很多个接口
	3. 接口与接口之间是多继承的，一个接口可以继承多个接口

注意事项：
	1. 多个父类接口当中的抽象方法如果重复，没关系（因为抽象方法没有方法体）
	2. 多个父类接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，而且要带着default关键字

![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/7133CB15-65C0-4C7A-BD40-5247141DBD0B.png)
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/13FB557B-29E5-45A3-ABF5-691A911D56F1.png)
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/4039117A-2384-4FF3-A3AB-1A9D913A35CB.png)
会报错：虽然两个父接口中method()重复，但是它是抽象方法，所以没关系。报错是因为，两个父接口中的默认方法重复了，需要重新覆盖重写（实现）
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/D06F9705-3313-421B-8967-A67F48D525F6.png)


## 10.14 多态的概述
面向对象三大特征：封装性、继承性、多态性
多态指多种形态
extends继承或者implements实现，是多态性的前提

## 10.15 多态的格式与使用
代码当中体现多态性，其实就是一句话，::父类引用指向子类对象::
	* 父类名称 对象名 = new 子类名称();
	* 接口名称 对象名 = new 实现类名称();
左父右子就是多态

## 10.16 多态中成员变量的使用特点
跟之前一样，访问成员变量的两种方法：
	* 直接通过对象名称访问成员变量，看等号左边是谁，优先用谁，没有则向上找
	* 间接通过成员方法访问成员变量，看该方法属于谁，优先用谁，没有则向上找

## 10.17 多态中成员方法的使用特点
在多态的代码当中，成员方法的访问规则是：
	看new的是谁，就优先用谁，没有则向上找

口诀：
* 成员方法：::编译看左边，运行看右边::
* 成员变量：编译看左边，运行还看左边
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-19%2011.03.05.png)

## 10.18 使用多态的好处
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-19%2011.08.05.png)


## 10.19 对象的向上转型
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-19%2011.10.39.png)

## 10.20 对象的向下转型
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-19%2011.22.10.png)

## 10.21 用instanceof关键字进行类型判断
如果才能知道一个父类的引用对象，本来是什么子类？
格式：
	对象 instance 类名称
会得到一个boolean值结果，判断前面的对象能不能当作后面类型的实例
![](10%20%E6%8E%A5%E5%8F%A3%20%E5%A4%9A%E6%80%81/%E6%88%AA%E5%B1%8F2021-01-19%2011.26.11.png)

