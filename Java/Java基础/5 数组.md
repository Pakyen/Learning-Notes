# 5 数组

## 5.1 数组的概念
数组是一种容器，可以同时存放多个数据值

数组的特点：
	1. 数组是一种引用数据类型
	2. 数组当中的多个数据，类型必须统一
	3. 数组的长度在程序运行期间不可改变

## 5.2 数组的初始化
数组的初始化：在内存当中创建一个数组，并且向其中赋予一些默认值

两种常见的初始化方式：
	1. 动态初始化（指定长度）
	2. 静态初始化（指定内容）

* 动态初始化数组的格式：
数据类型[] 数组名称 = new 数据类型[数组长度];

* 静态初始化数组的格式：
数据类型[] 数组名称 = new 数据类型[] {元素1, 元素2, …}; 

* 省略的静态初始化：
数据类型[] 数组名称 = {元素1, 元素2, …};

注意事项：
	1. 静态初始化没有直接指定长度，但是仍然会自动推算得到长度
	2. 静态初始化标准格式可以拆分成两个步骤
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2010.49.09.png)
	3. 动态初始化也可以拆分成两个步骤  
	4. 静态初始化一旦使用省略格式，就不能拆分成两个步骤了

## 5.3 访问数组元素进行获取
java中直接打印数组名称，得到的是数组对应的，内存地址哈希值
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2010.50.55.png)
[ 表示是数组
I 表示代表里面全是int
@后面的是16进制

访问数组元素的格式：数组名称[索引值]

## 5.4 访问数组元素进行赋值
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2010.54.40.png)
静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值

## 5.5 Java中的内存划分
Java的内存需要划分成为5个部分：

	1. 栈(Stack)内存: 存放的都是方法中的局部变量。方法的运行一定要找栈当中

		局部变量：方法的参数，或者是方法{}内部的变量
		作用域：一旦超出作用域，立刻从栈内存当中消失

	2. 堆(Heap)内存：凡是new出来的东西，都在堆当中（new出来的对象和数组），在堆中分配的内存，由java虚拟机自动垃圾回收器来管理

		在程序中创建一个对象时，这个对象会被保存在堆内存里，以便反复利用
		堆内存里的东西都有一个地址值：16进制
		堆内存里面的数据，都有默认值。
		规则：
			如果是整数		默认为0
			如果是浮点数	默认为0.0
			如果是字符		默认为单引号'\u0000’
			如果是布尔		默认为false
			如果是引用类型	默认为null

	
		![](5%20%E6%95%B0%E7%BB%84/20160918162709617.jpeg)
在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。

	3. 方法区(Method Area)：存储.class相关信息，包含方法的信息，方法的运行一定要在栈当中
	4. 本地方法栈(Native Method Stack): 与操作系统相关
	5. 寄存器(pc Register): 与CPU相关

## 5.6 一个数组的内存图
<a href='08_%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.flv'>08_一个数组的内存图.flv</a>
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2011.23.11.png)

## 5.7 两个数组的内存图
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2011.29.12.png)

## 5.8 两个引用指向同一个数组的内存图

注意这里是把arrayA数组的地址值，赋值给arrayB数组
![](5%20%E6%95%B0%E7%BB%84/62C78B90-129F-4BAA-8793-57421D77E50B.png)
然后再更改arrayB[1]和arrayB[2]，看看arrayA的数据会不会被更改
![](5%20%E6%95%B0%E7%BB%84/777C366B-3927-4B27-8C90-23CDE7EAE758.png)
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2011.45.03.png)
⚠️结果：更改arrayB[1]和arrayB[2]后，arrayA的数据也会被更改

内存图：
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2011.38.42.png)
虽然一个数组名字叫做A，一个叫做B，但他们的内存地址相同，所以本质上他们是同一个数组

## 5.9 常见问题1 数组索引越界异常
## 5.10 常见问题2 空指针异常
有时候可能分了两个步骤来创建数组，如果忘记了第二步
那就是只是定义，没有new，没有创建，那就只是有一个空壳
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2011.49.00.png)
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2011.50.45.png)
所有的引用类型变量，都可以赋值为一个null值， 代表其中什么都没有

数组必须进行new初始化才能使用其中的元素
如果只是赋值了一个null，没有进行null创建，
那么将会发生空指针异常 NullPointerException

原因：忘了new
解决：补上new

## 5.11 获取数组的长度
如何获取数组的长度，格式为：
	数组名称.Length
这将会得到一个int数字，代表数组的长度
::数组一旦创建，程序运行期间，长度不可改变::

但有下面这种情况
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2011.53.49.png)
看似数组长度改变了其实并不是！！！
arrayC只是一个引用变量，实际上这是两个数组，是把另一个数组的地址重新赋值给了arrayC罢了

## 5.12 数组作为方法参数__传递地址
数组可以作为方法的参数
当调用方法的时候，向方法的小括号进行传参，传递进去的其实是数组的地址值。
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2012.01.03.png)
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2012.01.17.png)

## 5.13 数组作为方法返回值__返回地址
一个方法可以有0、1、多个参数：但是只能有0或者1个返回值，不能有多个返回值
如果希望一个方法当中产生的多个数据都进行返回，怎么办？
解决方案：使用一个数组作为返回值类型即可

	* 数组作为方法的参数，传递进去的其实是数组的地址值
	* 数组作为方法的返回值，返回的其实也是数组的地址值
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2012.04.12.png)
![](5%20%E6%95%B0%E7%BB%84/%E6%88%AA%E5%B1%8F2021-01-10%2012.04.37.png)








	














