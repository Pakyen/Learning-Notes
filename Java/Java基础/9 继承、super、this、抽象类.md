# 9 继承、super、this、抽象类

# 9.1 继承
## 9.1.1 继承的概述
面向对象的三大特征：封装性、继承性、多态性
继承是多态的前提，如果没有继承，就没有多态

继承主要解决的问题是：::共性抽取::
![](9%20%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/%E6%88%AA%E5%B1%8F2021-01-17%2010.45.29.png)

## 9.1.2 继承的格式
在继承的关系中，“子类就是一个父类”；也就是说，子类可以被当作父类看待
例如父类是员工，子类是讲师，那么讲师就是一个员工 关系：is-a

定义父类的格式：（一个普通的类定义）
public class 父类名称 {…}

定义子类的格式：
public class 子类名称 extends 父类名称 {…}


## 9.1.3 继承中成员变量的访问特点
在父子类的继承关系中，如果成员变量重名，则创建子类对象时，访问有两种方式： 
	* 直接通过子类对象访问成员对象：
		* 等号左边（对象）是谁，就优点用谁，没有则向上找
	* 间接通过成员方法访问成员变量：
		* 该方法属于谁，就有限用谁，没有则向上找

## 9.1.4 区分子类方法中重名的三种变量
如果：父类成员变量、本类成员变量、局部变量 重名？

局部变量：			直接写成员变量名
本类的成员变量：	this.成员变量名
父类的成员变量：	super.成员变量名
![](9%20%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/%E6%88%AA%E5%B1%8F2021-01-17%2011.19.55.png)

## 9.1.5 继承中成员方法的访问特点
子类和父类有重名的方法时：
在父子类的继承关系中，创建子类对象，访问成员方法的规则：
	创建的对象是谁，就优先用谁，没有则向上找
注意事项：
	无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的东西
 
## 9.1.6 继承中方法的覆盖重写override

	* 重写（Override)
		* 在继承关系当中，方法的名称一样， ~参数列表也一样~ 【覆盖重写】
	* 重载（Overload)
		* 方法的名称一样，参数列表不一样

* 方法覆盖重写的特点：创建的是子类对象，则优先用子类方法

## 9.1.7 继承中方法覆盖重写的注意事项
	1. 必须保证父子类方法之间的名称相同，参数列表也相同

	2. @override：写在方法前面，用来检测是不是有效的正确覆盖重写

	3. 子类方法的返回值，必须【小于等于】父类方法的返回值范围
	ps:	java.lang.Object类是所有类的公共最高父类（祖宗类）

	4. 子类方法的权限，必须【大于等于】父类方法的权限修饰符
	ps: public > protected > (default) > private
	ps: (default)不是关键字，而是什么都不写

	5. 设计原则：
		* 对于已经投入使用的类，尽量不要进行修改
		* 推荐定义一个新的类，来重复利用其中的共性内容，并且添加改动的新内容
		* 想对方法改动或添加新内容，可以在子类中覆盖重写

## 9.1.8 继承中构造方法的访问特点
	1. 子类构造方法当中有一个默认隐含的“super();”调用，如果子类没写构造方法，所以一定是先调用父类的无参构造方法
	2. 如果父类定义了有参构造方法，没定义无参构造方法（编译器也不赠送了），那么子类不定义也不使用有参构造的话，就会报错
	3. 调用父类有参构造方法的格式：
		通过super关键字调用父类重载构造
![](9%20%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/%E6%88%AA%E5%B1%8F2021-01-17%2011.49.34.png)
	4. 只有子类构造方法才能调用父类构造方法，普通方法不行
	5. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造方法调用多次super构造

## 9.1.9 super关键字的三种用法
	1. 在子类的成员方法中，访问父类的成员变量（super.父类成员变量名）
	2. 在子类的成员方法中，访问父类的成员方法（super.method();）
	3. 在子类的构造方法中，访问父类的构造方法
- - - -
## 9.2 this关键字
## 9.2.1 this关键字的三种用法
this关键字用来访问本类内容，用法也有三种：
	1. 在本类的成员方法中，访问本类的成员变量
![](9%20%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/%E6%88%AA%E5%B1%8F2021-01-17%2011.56.48.png)

	2. 在本类的成员方法中，访问本类的另一个成员方法
![](9%20%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/%E6%88%AA%E5%B1%8F2021-01-17%2011.58.13.png)

	3. 在本类的 ~构造方法~ 中，访问本类的另一个 ~构造方法~
在第三种方法中要注意：
	A. this(…)调用也必须是构造方法的第一个语句，且是唯一一个（调用构造方法）
	B. super和this两种构造调用，不能同时使用，因为调用构造方法只能是唯一的

## 9.2.2 super与this内存图解
<a href='12_super%E4%B8%8Ethis%E5%85%B3%E9%94%AE%E5%AD%97%E5%9B%BE%E8%A7%A3.flv'>12_super与this关键字图解.flv</a>
![](9%20%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/%E6%88%AA%E5%B1%8F2021-01-17%2012.26.09.png)

## 9.3 Java继承的三个特点
Java语言是::单继承::的，一个类的直接父类只能有唯一一个
Java语言可以::多级继承::：爷爷、父亲、儿子、孙子等
![](9%20%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/%E6%88%AA%E5%B1%8F2021-01-17%2012.38.35.png)
一个子类的直接父类是唯一的，但是一个父类可以有多个子类，所以一个类可以有很多个兄弟姐妹

## 9.4 抽象
## 9.4.1 抽象方法和抽象类的格式
抽象方法，就是加上abstract关键字，然后去掉大括号，直接分号结束
抽象类，抽象方法所在的类，必须是抽象类才行，在class前加上abstract即可
![](9%20%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/2983D4B8-DAEA-4748-A231-71CF10FF41F8.png)

## 9.4.2 抽象方法和抽象类的使用
	1. 不能直接创建new抽象类对象
	2. 必须有一个子类来继承抽象父类
	3. 子类必须覆盖重写抽象父类中的所有抽象方法
	【覆盖重写】（实现）：子类去掉抽象方法中的abstract关键字，然后补上方法体大括号
	4. 创建子类对象进行使用

## 9.4.3 抽象方法和抽象类的注意事项
	1. 抽象类不能创建对象
	2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的
	3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类
	4. 抽象类的子类，必须重写抽象父类中的所有抽象方法。否则编译无法通过，除非该子类也是抽象类
![](9%20%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/%E6%88%AA%E5%B1%8F2021-01-17%2015.00.37.png)